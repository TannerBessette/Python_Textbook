---
title: "Undergraduate Research with a Tennis Data Case Study"
format: 
  revealjs:
    transition: fade
    theme: serif
    slide-number: true
    footer: "Oregon State Seminar"
author: "Matt Higham"
institute: "St. Lawrence University"
date: May 6, 2024
embed-resources: true
---

## About Me

:::: {.columns}

::: {.column width="30%"}
![](mipha_pics/IMG_2667.JPG)
:::

::: {.column width="70%"}
* PhD from Oregon State in 2019.
* Dissertation: _Spatial prediction for finite populations with ecological applications_.
:::

::::

::: {.notes}
I want to first start off by thanking Lisa for the invitation to speak at today's seminar. I'm excited to discuss a little bit about this cool undergraduate research project I advised this last year as well as what undergraduate research looks like more generally.

But first, a little bit about myself for those who don't know me. I graduated from Oregon State back in 2019. Here is a selfie that I forced my advisors and committee members to take with me after me doctoral defense in the good ol' Weniger conference room. Students, even if you tune out for the rest of this talk, if there's one thing you should remember about the entire thing is that taking a picture to commemorate your master's or doctoral oral is a great idea. I felt a little silly at the time but it's nice to have the picture now! 

:::


## About Me: Mipha!

![](mipha_pics/IMG_5826.jpg)

::: {.notes}

And, I'd be remiss if I didn't have one picture of my best friend, Mipha. And yes, for the nerds out there, she is named after a character in zelda breath of the wild.

:::

## St. Lawrence University

:::: {.columns}

::: {.column width="50%"}
![](mipha_pics/Fast-Facts.jpg)
:::

::: {.column width="50%"}
* currently an Assistant Professor at St. Lawrence University.
    * teaching-focused liberal arts college in northern New York.
    * ~ 2000 - 2400 students.
    * majors in Statistics and in Data Science.
:::

::::

::: {.notes}

Currently, I am an assistant professor at St. Lawrence University, which is a small liberal arts university in Northern new york.

:::

## A Teaching Focused Career

* how I spend my time during the semester:
    * teaching, course development, undergraduate research projects, etc.
* how I spend my time during the summer:
    * research
    * rest and relaxation

::: {.notes}

Being at a teaching-focused university, I spend much of my time teaching as well as mentoring undergraduate research projects, while most of my own research is done in the summer. There is some overlap in that I will do a little course development in the summer and I'll also get a little of my own research done during the semester. But, for me at least, that breakdown is fairly accurate.

:::

## Talk Goals

* Explain how Bayesian modeling can be used to give in-match-win probability for professional tennis matches.
* Explain how an undergraduate research project differs from graduate level research.

::: {.notes}

Alright, so, getting more into the topic of the talk, I'll be discussing an undergraduate research project that I advised this past year on Bayesian modeling for win probability in professional tennis matches. This is one of my favorite projects I've mentored. In comparing to a more traditional research seminar, you can expect the content to be a little lighter, which I think is a good thing. You all are in the middle of the quarter and I am at the end of our semester, so a light seminar without a lot of complicated formula might just hit the spot.

:::

```{r}
#| output: false
library(tidyverse)
library(compr)
library(broom)
library(dplyr)
library(readr)
library(deuce)
library(ggplot2)
library(knitr)
library(kableExtra)

# Source the functions
source("comp_prior_start.R")
source("bayes_intro.R")
source("wrangle_point_level_data.R")
source("Create_Prior.R")
source("get_probabilities_df.R")
source("get_plot_df.R")
```

```{r}
sin_alc_paired <- wrangle_point_level(ext = "2022-usopen-points.csv",
                               ID = "2022-usopen-1503")

sin_serving <- sin_alc_paired[[1]]
alc_serving <- sin_alc_paired[[2]]
```

## Tennis Case Study

![](auso_probabilities.jpg)

::: {.notes}

So, the motivation for this project lies in trying to come up with a model for win probability for tennis matches at a specific point in the middle of the match. If you watch tennis, you'll sometimes see these win probabilities shown on the screen, as in the screenshot here. But, how these are calculated is mysterious. I would love it if the network gave a QR code to a reproducible GitHub repository that has all of the methodology in calculating these win probabilities, but, alas, that is not the world that we live in. So, this is the end goal: to come up with a method to obtain a probability that a player will win a match at various stages of the match.

:::

## Bayesian Prior, Data, and Posterior

![Johnson, A. A., Ott, M. Q., & Dogucu, M. (2021). Bayes Rules! An Introduction to Applied Bayesian Modeling](bayesian_diagram.jpeg)

::: {.notes}

In this project, we use Bayesian modeling to obtain a predicted win probability at a specific point in a tennis match. Recall that, for a Bayesian model, we start off with some prior information about a parameter of interest, which is random, not fixed. We then obtain some data to update the prior beliefs about the parameter, which generates a posterior distribution. 

To talk through this for this specific context, letâ€™s consider the match between Carlos Alcaraz and Jannik Sinner in the 2022 US Open quarterfinals as our example throughout the talk. In this case, the parameters we are looking at are the probabilities that Alcaraz wins a point while serving against Sinner, and that Sinner wins a point while serving against Alcaraz. We come up with our prior beliefs about these probabilities using different matches that have already happened. As the match between Sinner and Alcaraz is played, this is our data that comes in, and after each successive point that is played, we update their probabilities of winning a point while serving, and achieve our posterior distributions.

:::

## Prior Distribution

```{r}
prior_sin_logodds <- 0.2434863
prior_sin_sd_logodds <- 0.1193404

prior_sin_df <- tibble::tibble(logodds = rnorm(200000,
                                                 prior_sin_logodds,
                                                 prior_sin_sd_logodds),
                           prob = expit(logodds))

prior_alc_logodds <- 0.5017383
prior_alc_sd_logodds <- 0.1196950

prior_alc_df <- tibble::tibble(logodds = rnorm(200000,
                                                 prior_alc_logodds,
                                                 prior_alc_sd_logodds),
                           prob = expit(logodds))

both_priors_df <- bind_rows(prior_sin_df, prior_alc_df, .id = "type") |>
  mutate(type = fct_recode(type, "Sinner" = "1",
                           "Alcaraz" = "2"),
         type = fct_relevel(type, c("Sinner", "Alcaraz")))

ggplot(data = both_priors_df, aes(x = prob)) +
  geom_density(aes(colour = type), adjust = 2,
               linewidth = 1.4) + ## adjust smooths it out
  scale_colour_viridis_d(end = 0.9) +
  theme_minimal() +
  labs(title = "Prior Distributions for Sinner and Alcaraz",
       x = "Probability of Winning a Point (on serve)",
       y = "Density",
       caption = "Prior includes matches from leadup tournaments to 2022 USO and 2022 USO itself") +
  theme_bw(base_size = 20)
```

::: {.notes}

The graph here gives the prior distributions for Sinner winning a point serving against Alcaraz (in blue) and Alcaraz winning a point serving against Sinner (in green) based on matches played in the lead-up tournaments to their U.S. Open clash and in the earlier rounds of the U.S. Open itself. So, these prior distributions are for point-win probabilities, not the match-win probability that we are ultimately after: we'll get to that later. Based on this prior information, we see that Alcaraz has a higher probability of winning a point on serve, which is not too surprising since, at this point in their careers, Alcaraz was the 3rd best player in the world while Sinner was the 11th best player.
:::

## Data + Posterior

```{r}
#| warning: false
#| output: false
p1_serving_df <- sin_serving |> slice(1:150)

p1_serving_df |>
  summarise(points_won = sum(PointWinner == 1),
            points_played = n(),
            prop_won = points_won / points_played)

alc_serving |>
  summarise(points_won = sum(PointWinner == 2),
            points_played = n(),
            prop_won = points_won / points_played)

p1_niter <- p1_serving_df |> nrow()

p1_prob_store <- double()
  
p1_serving <- p1_serving_df |>
    # also create indicator if serving player won the point
    mutate(server_won = ifelse(PointWinner == 1, 1, 0))
  
mod <- stan_glm(server_won ~ 1, data = p1_serving |> slice(1:p1_niter),
                    family = binomial,
                    prior_intercept = normal(prior_sin_logodds, prior_sin_sd_logodds),
                    seed = 123)
coef(mod) |> expit()

# use above to pull specific probabilities at a state of the match

tibble_mod <- as_tibble(mod) |>
  mutate(prob = expit(`(Intercept)`)) |>
  rename(logodds = `(Intercept)`)

ggplot(data = tibble_mod, aes(x = prob)) +
  geom_density(adjust = 5, linewidth = 0.9)

plot_df <- bind_rows(tibble_mod, prior_sin_df, .id = "type") |>
  mutate(type = fct_recode(type, "posterior" = "1",
                           "prior" = "2"),
         type = fct_relevel(type, c("prior", "posterior")))
```

```{r}
ggplot(data = plot_df, aes(x = prob)) +
  geom_density(aes(linetype = "prior"), adjust = 2,
               linewidth = 0.9) + ## adjust smooths it out
  theme_minimal() +
  labs(title = "Prior Distribution for Jannik Sinner",
       x = "Sinner's Probability of Winning a Point (on serve)",
       y = "Density") +
  coord_cartesian(ylim = c(0, 17)) +
  theme_bw(base_size = 22)
```

::: {.notes}

So, the big idea is that if we start with a prior distribution for Sinner winning a point against Alcaraz before their Quarterfinal U.S. Open match, we can use the points that are played throughout the match as the data that, when combined with the prior, generates the posterior distribution. 
:::

## Data + Posterior

```{r}
ggplot(data = plot_df, aes(x = prob)) +
  geom_density(aes(linetype = type), adjust = 2,
               linewidth = 0.9) + ## adjust smooths it out
  theme_minimal() +
  labs(title = "Prior and Posterior Distributions at Specific Match State",
       subtitle = "Sinner serving at 40-15, 1-1, 3rd set",
       x = "Sinner's Probability of Winning a Point (on serve)",
       y = "Density",
       caption = "Sinner: 89/150 points won on serve") +
  coord_cartesian(ylim = c(0, 17)) +
  theme_bw(base_size = 22)
```

::: {.notes}

As an example, we see that, at this point in the match, Sinner had won 89 out of 150 points on serve (or, about 60% of the points on serve). So, we see the center of the posterior distribution shift a bit more toward 0.6. Additionally, as we get more data, we also see the spread of the posterior distribution shrink compared to the spread of the prior distribution.

We can think about a slightly different posterior as each successive point is played in the match.
:::

## Prior Distribution: Paired Competition Model

* define $Y_{ijk}$ be a Bernoulli random variable equal to 
    * $1$ if player $i$ wins the $k^{th}$ point against player $j$.
    * $0$ if player $i$ loses the $k^{th}$ point against player $j$.
* $\text{E}(Y_{ijk}) \equiv \pi_{ijk}$, the probability that Player $i$ wins the $k^{th}$ point against Player $j$.

::: {.notes}

Alright, so that is the big picture of what is happening with this project. Looking a little bit more at the details of how the prior distributions are generated, we used a paired competition model with points played from all of the matches in the lead-up tournaments to the U.S. Open for that year.

::: 



## Prior Distribution: Paired Competition Model

$$
\text{logit}(\pi_{ijk}) = \beta_{alcaraz}X_{alcaraz} + \beta_{sinner}X_{sinner} + \ldots + \beta_{ruud}X_{ruud},
$$

* $X_{alcaraz}$ is equal to 
    * $1$ if Alcaraz is player $i$ on the $k^{th}$ point.
    * $0$ if Alcaraz is neither player $i$ nor player $j$ on the $k^{th}$ point.
    * $-1$ if Alcaraz is player $j$ on the $k^{th}$ point.
* $\beta_{alcaraz}$ represents a unitless "ability" of Alcaraz.

::: {.notes}

So our data here are points, which we assume are independent. Then the model we use, which is sometimes referred to as a Bradley-Terry model, looks pretty much like a standard logistic regression model, except that, instead of standard indicator variables, the x variables here can take on values of 1, 0, or -1 to account for the fact that there are two players in each point.

:::

## Paired Competition Model: Example

* log-odds of Carlos Alcaraz (player $i$) winning a point against Jannik Sinner (player $j$):

\begin{equation}
  \begin{aligned}
    \text{logit}(\pi_{ij}) & = \beta_{alcaraz}(1) + \beta_{sinner}(-1) + \ldots + \beta_{ruud}(0) \\
                                 & = \beta_{alcaraz} - \beta_{sinner}
  \end{aligned}
\end{equation}

::: {.notes}

In our Alcaraz-Sinner example, we end up with this equation for the log odds that Alcaraz wins a point. As alcaraz's "ability" goes up his probability of winning a point increases and as sinner's ability goes up, alcaraz's probability of winning a point decreases.
:::

## Prior Distribution

```{r}
#| warning: false
library(tidygraph)
matches2022 <- purrr::map("atp_matches_2022.csv", read_matches) |>
  bind_rows() |>
  select(winner_name, loser_name)

matches2022 <- purrr::map("atp_matches_2022.csv", read_matches) |>
  bind_rows() |>
  filter(winner_seed <= 2 & best_of == 5) |>
  select(winner_name, loser_name)

set.seed(12)
random_sample <- matches2022 |> sample_n(20)

player_names <- tibble(player1 = random_sample$winner_name,
                       player2 = random_sample$loser_name)

player_names <- tibble(
  player1 = c("Felix Auger Aliassime", "Novak Djokovic", "Daniil Medvedev", "Carlos Alcaraz", "Jannik Sinner", 
              "Rafael Nadal", "Casper Ruud", "Holger Rune", "Andrey Rublev", "Tommy Paul", "Sebastian Korda", 
              "Taylor Fritz", "Felix Auger Aliassime", "Felix Auger Aliassime", "Daniil Medvedev", "Taylor Fritz"),
  player2 = c("Novak Djokovic", "Daniil Medvedev", "Carlos Alcaraz", "Novak Djokovic", "Rafael Nadal", "Casper Ruud", 
              "Holger Rune", "Andrey Rublev", "Tommy Paul", "Sebastian Korda", "Taylor Fritz", 
              "Felix Auger Aliassime", "Felix Auger Aliassime", "Rafael Nadal", "Jannik Sinner", "Casper Ruud")
)

nodes_tennis <- player_names |> pivot_longer(c(player1, player2),
                             names_to = "player_num",
                             values_to = "player") |>
  distinct(player) |>
  rowid_to_column("id") |>
  rename(label = player)

player_sum <- player_names |> 
  mutate(p1 = if_else(player1 > player2,
                      true = player2,
                      false = player1),
         p2 = if_else(player1 > player2,
                      true = player1,
                      false = player2)) |>
  select(-player1, -player2) |>
  group_by(p1, p2) |>
  summarise(n = n())

# create edges to match with ids
edges_tennis <- left_join(player_sum, nodes_tennis, 
                   by = join_by(p1 == label)) |>
  rename(from = "id") |>
  left_join(nodes_tennis, by = join_by(p2 == label)) |>
  rename(to = "id") |>
  ungroup() |>
  dplyr::select(to, from, n)
# create network obj
network_obj_tennis <- tbl_graph(nodes = nodes_tennis, edges = edges_tennis, directed = FALSE)

library(ggraph)
ggraph(network_obj_tennis |> mutate(centrality = centrality_authority()),
                            layout = "stress") +
  geom_edge_link(aes(width = n), alpha = 0.7, show.legend = FALSE) +
  geom_node_point(aes(size = centrality)) +
  scale_edge_width(range = c(0.5, 3)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 7)  +
  scale_colour_viridis_d() +
  guides(size = "none") +
  labs(title = "Network Diagram")
```

```{r}
#| eval: false
#| warning: false
# make network for our actual prior

tourn_name = "US Open"
surf = "Hard"
start_date = "2022-07-25"
end_date = "2022-09-06"
sin_alc_network_sp <- purrr::map("atp_matches_2022.csv", read_matches) |>
  bind_rows() |>
    mutate(tourney_date = lubridate::ymd(tourney_date)) |>
    filter((tourney_name == tourn_name | surface == surf) &
           (tourney_date <= lubridate::ymd(end_date) & tourney_date >= lubridate::ymd(start_date))) |>
  select(winner_name, loser_name)

player_names_sp <- tibble(
  player1 = sin_alc_network_sp$winner_name,
  player2 = sin_alc_network_sp$loser_name
)

nodes_tennis_sp <- player_names_sp |> pivot_longer(c(player1, player2),
                             names_to = "player_num",
                             values_to = "player") |>
  distinct(player) |>
  rowid_to_column("id") |>
  rename(label = player)

player_sum_sp <- player_names_sp |> 
  mutate(p1 = if_else(player1 > player2,
                      true = player2,
                      false = player1),
         p2 = if_else(player1 > player2,
                      true = player1,
                      false = player2)) |>
  select(-player1, -player2) |>
  group_by(p1, p2) |>
  summarise(n = n())

# create edges to match with ids
edges_tennis_sp <- left_join(player_sum_sp, nodes_tennis_sp, 
                   by = join_by(p1 == label)) |>
  rename(from = "id") |>
  left_join(nodes_tennis_sp, by = join_by(p2 == label)) |>
  rename(to = "id") |>
  ungroup() |>
  dplyr::select(to, from, n)
# create network obj
network_obj_tennis_sp <- tbl_graph(nodes = nodes_tennis_sp, edges = edges_tennis_sp, directed = FALSE)

library(ggraph)
ggraph(network_obj_tennis_sp |> mutate(centrality = centrality_authority()),
                            layout = "stress") +
  geom_edge_link(aes(width = n), alpha = 0.7, show.legend = FALSE) +
  geom_node_point(aes(size = centrality)) +
  scale_edge_width(range = c(0.5, 3)) +
  geom_node_text(aes(label = label), repel = TRUE)  +
  scale_colour_viridis_d() +
  guides(size = "none") +
  labs(title = "Network Diagram")

sin_alc_network_sp |> filter(winner_name == "Carlos Alcaraz" | loser_name == "Carlos Alcaraz")
sin_alc_network_sp |> filter(winner_name == "Jannik Sinner" | loser_name == "Jannik Sinner")
```

::: {.notes}
This is a hypothetical network diagram of matches played that might form the prior distribution. The model is able to estimate the parameters as long as the players of interest are connected in any way. This is important because its entirely possible that Alcaraz and Sinner did not play in any of the lead-up tournaments prior to their U.S. open match. But, we can still get the appropriate prior distributions if they have any connection.
:::

## Adding a Server Effect

\begin{equation}
  \begin{aligned}
    \text{logit}(\pi_{ijk}) = & \beta_{alcaraz}X_{alcaraz} + \beta_{sinner}X_{sinner} + \ldots + \beta_{ruud}X_{ruud} + \\
    & \alpha_{alcaraz}X_{alcaraz,s} + \alpha_{sinner}X_{sinner,s} + \ldots + \alpha_{ruud}X_{ruud,s}
  \end{aligned}
\end{equation}

* $X_{alcaraz,s}$ is equal to
    * $1$ if Alcaraz is the serving player $i$ on point $k$.
    * $0$ if Alcaraz is the returning player on point $k$ or if Alcaraz is neither player $i$ nor player $j$.
    * $-1$ if Alcaraz is the serving player $j$ on point $k$
* $\alpha_{alcaraz}$ represents a bump in point win probability for when Alcaraz serves compared to when he receives.

::: {.notes}
In tennis, who is serving is important to take into account when thinking about the probability of a player winning the point. I'll gloss over these next couple slides, but they just show that we can incorporate who is serving on each point as a covariate into the model.
:::

## Server Effect: Example

* log-odds of Carlos Alcaraz (player $i$) winning a point against Jannik Sinner (player $j$) with Alcaraz serving on point $k$:

\begin{equation}
  \begin{aligned}
    \text{logit}(\pi_{ijk}) & = \beta_{alcaraz}(1) +       \beta_{sinner}(-1) + \ldots + \beta_{ruud}(0) + \\
    & \;\;\;\; \alpha_{alcaraz}(1) + \alpha_{sinner}(0) + \ldots + \alpha_{ruud}(0) \\
    & = \beta_{alcaraz} + \alpha_{alcaraz} - \beta_{sinner}
  \end{aligned}
\end{equation}

::: {.notes}
And we wind up with a different equation for when Alcaraz is serving (which has an extra parameter that gives him a small bump when he is serving).
:::

## Server Effect: Example

* log-odds of Carlos Alcaraz (player $i$) winning a point against Jannik Sinner (player $j$) with Sinner serving on point $k$:

\begin{equation}
  \begin{aligned}
    \text{logit}(\pi_{ijk}) & = \beta_{alcaraz}(1) +       \beta_{sinner}(-1) + \ldots + \beta_{ruud}(0) + \\
    & \;\;\;\; \alpha_{alcaraz}(0) + \alpha_{sinner}(-1) + \ldots + \alpha_{ruud}(0) \\
    & = \beta_{alcaraz} - \beta_{sinner} - \alpha_{sinner}
  \end{aligned}
\end{equation}

::: {.notes}
Compared to when Sinner is serving. So, now these probabilities change depending on who is serving.
:::

## Prior Distribution

```{r}
prior_sin_logodds <- 0.2434863
prior_sin_sd_logodds <- 0.1193404

prior_sin_df <- tibble::tibble(logodds = rnorm(200000,
                                                 prior_sin_logodds,
                                                 prior_sin_sd_logodds),
                           prob = expit(logodds))

prior_alc_logodds <- 0.5017383
prior_alc_sd_logodds <- 0.1196950

prior_alc_df <- tibble::tibble(logodds = rnorm(200000,
                                                 prior_alc_logodds,
                                                 prior_alc_sd_logodds),
                           prob = expit(logodds))

both_priors_df <- bind_rows(prior_sin_df, prior_alc_df, .id = "type") |>
  mutate(type = fct_recode(type, "Sinner" = "1",
                           "Alcaraz" = "2"),
         type = fct_relevel(type, c("Sinner", "Alcaraz")))

ggplot(data = both_priors_df, aes(x = prob)) +
  geom_density(aes(colour = type), adjust = 2,
               linewidth = 1.4) + ## adjust smooths it out
  scale_colour_viridis_d(end = 0.9) +
  theme_minimal() +
  labs(title = "Prior Distributions for Sinner and Alcaraz",
       x = "Probability of Winning a Point (on serve)",
       y = "Density",
       caption = "Prior includes matches from leadup tournaments to 2022 USO and 2022 USO itself") +
  theme_bw(base_size = 20)
```

::: {.notes}
Those are what is powering the generation of these prior distributions of winning a point on serve that we saw earlier. In addition to the center, we also obtain the variance of the estimator on the log-odds scale and assume normality of the estimator on the log-odds scale.
:::

## Data + Posterior

```{r}
ggplot(data = plot_df, aes(x = prob)) +
  geom_density(aes(linetype = type), adjust = 2,
               linewidth = 0.9) + ## adjust smooths it out
  theme_minimal() +
  labs(title = "Prior and Posterior Distributions at Specific Match State",
       subtitle = "Sinner serving at 40-15, 1-1, 3rd set",
       x = "Sinner's Probability of Winning a Point (on serve)",
       y = "Density",
       caption = "Sinner: 89/150 points won on serve") +
  coord_cartesian(ylim = c(0, 17)) +
  theme_bw(base_size = 22)
```

::: {.notes}
All of that is based on points in matches played prior to the match of interest. These prior distributions are then updated as points in the match are being played out.
:::


## Match-Win Probability vs Winning-Point Probability (on Serve)
 
::: {.callout-warning}
## We are looking at 3 different probabilities
1. probability of Sinner winning a point against Alcaraz on serve.
2. probability of Alcaraz winning a point against Sinner on serve.
3. overall match-win probability is calculated from (1) and (2).
:::

::: {.notes}
Just a quick reminder that we have not actually talked much about match-win probability yet, only point-win probabilities. We obtain posterior distributions of (1) and (2). Then, these posterior distributions are used to calculate the overall match-win probability more directly.
:::

## Calculating In-Match-Win Probability

![](tennis_game_flow_chart.png)

::: {.notes}
Once we have the posterior distribution of each of their serving probabilities, you can sample from those two posterior distributions. For given draws from the posterior distributions, you can then figure out the exact probability that a player wins the entire match, if you assume that points are played out independently (so there is no momentum).
:::

## Case Study 1: Alcaraz vs Sinner

  * In the 2022 US Open, Carlos Alcaraz faced Jannik Sinner in the quarterfinals
  * Alcaraz defeated Sinner in 5 sets, 6-3, 6-7(7), 6-7(0), 7-5, 6-3
  * We will look at probability of Alcaraz winning the match
  * Let $\tilde{p}$ be the posterior median probability of winning a point on serve:
    * $\tilde{p}_{alcaraz} = 0.6229$
    * $\tilde{p}_{sinner} = 0.5606$

::: {.notes}
So we'll see how this actually works for this particular match of interest. For those of you who are tennis fans, you might have recognized this match from the get-go. This match was an epic match with tons of swings in win probability that lasted over 5 hours and ended at 2:50 am.
:::

## Case Study 1: Alcaraz vs Sinner

```{r}
#| output: false
#| cache: true
combined_prob_sin_alc_sp_df <- get_probabilities_df(p1_serving_df = sin_serving,
                                 p2_serving_df = alc_serving,
                                 p1 = "Jannik Sinner",
                                 p2 = "Carlos Alcaraz",
                                 p1_original_prob = 0.2434863,
                                 p1_original_se = 0.1193404,
                                 p2_original_prob = 0.5017383,
                                 p2_original_se = 0.1196950)

plot_sin_alc_small_prior <- get_plot_df(combined_df = combined_prob_sin_alc_sp_df, 
                        which_player_prob = 2,
                        best_of_3 = FALSE,
                        advantage = FALSE,
                        type = "distribution") |>
  mutate(set_number = as.factor(as.numeric(total_sets))) |>
  # fix last row in data set where set_number is 6, should be a 5
  mutate(set_number = ifelse(pt_number == max(pt_number), '5', set_number)) |>
  mutate(set_number = as.factor(set_number))

fills <- c("#F57A5C", "#F5C25C", "#94E25B", "#69CEE0", "#A875CE")
```

```{r}
plot_first_set_sin_alc <- plot_sin_alc_small_prior |>
  filter(set_number == 1)

first_set_boundaries_alc_sin_small_prior <- plot_sin_alc_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1)
```

```{r}
plot_sin_alc_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_rect(data = first_set_boundaries_alc_sin_small_prior, aes(x = NULL, y = NULL, xmin = xmin, xmax = xmax, 
                                       ymin = -Inf, ymax = Inf, fill = set_number), alpha = 0.2) + 
  geom_line(data = plot_first_set_sin_alc, aes(y = win_prob_px)) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Alcaraz vs Sinner US Open Quarterfinal 2022",
       subtitle = "Probability of Alcaraz Winning Match",
       caption = "Prior contains 'lead-up' tournaments to the 2022 USO and 2022 USO itself",
       color = "Server") +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_sin_alc_small_prior))) +
  scale_fill_manual(values = fills[1]) +
  annotate("text", x = 32, y = 0.7, label = "Alcaraz wins") +
  annotate("text", x = 32, y = 0.65, label = "6-3") +
  theme_bw(base_size = 14)
```

::: {.notes}
We see that Alcaraz starts off with a fairly high probability of winning the match, as his prior point win probability was higher than Sinner's.
:::


## Case Study 1: Alcaraz vs Sinner

```{r}
plot_two_sets_sin_alc <- plot_sin_alc_small_prior |>
  filter(set_number == 1 | set_number == 2)

two_set_boundaries_alc_sin_small_prior <- plot_sin_alc_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1 | set_number == 2)
```

```{r}
plot_sin_alc_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_rect(data = two_set_boundaries_alc_sin_small_prior, aes(x = NULL, y = NULL, xmin = xmin, xmax = xmax, 
                                       ymin = -Inf, ymax = Inf, fill = set_number), alpha = 0.2) + 
  geom_line(data = plot_two_sets_sin_alc, aes(y = win_prob_px)) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Alcaraz vs Sinner US Open Quarterfinal 2022",
       subtitle = "Probability of Alcaraz Winning Match",
       caption = "Prior contains 'lead-up' tournaments to the 2022 USO and 2022 USO itself",
       color = "Server") +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_sin_alc_small_prior))) +
  scale_fill_manual(values = fills[1:2]) +
  theme_bw(base_size = 14) +
  annotate("text", x = 110, y = 0.6, label = "Sinner wins") +
  annotate("text", x = 110, y = 0.55, label = "7-6(7)")
```

::: {.notes}
You can see that, as the match plays out, Alcaraz's win probability gets above 0.9. In the second set, Sinner saved three set points in a row serving at 5-6, 0-40 and eventually came back to win the set.
:::

## Case Study 1: Alcaraz vs Sinner

```{r}
plot_three_sets_sin_alc <- plot_sin_alc_small_prior |>
  filter(set_number == 1 | set_number == 2 | set_number == 3)

three_set_boundaries_alc_sin_small_prior <- plot_sin_alc_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1 | set_number == 2 | set_number == 3)
```

```{r}
plot_sin_alc_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_rect(data = three_set_boundaries_alc_sin_small_prior, aes(x = NULL, y = NULL, xmin = xmin, xmax = xmax, 
                                       ymin = -Inf, ymax = Inf, fill = set_number), alpha = 0.2) + 
  geom_line(data = plot_three_sets_sin_alc, aes(y = win_prob_px)) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Alcaraz vs Sinner US Open Quarterfinal 2022",
       subtitle = "Probability of Alcaraz Winning Match",
       caption = "Prior contains 'lead-up' tournaments to the 2022 USO and 2022 USO itself",
       color = "Server") +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_sin_alc_small_prior))) +
  scale_fill_manual(values = fills[1:3]) +
  theme_bw(base_size = 14) +
  annotate("text", x = 200, y = 0.5, label = "Sinner wins") +
  annotate("text", x = 200, y = 0.45, label = "7-6(0)")
```

::: {.notes}
The match continues.
:::

## Case Study 1: Alcaraz vs Sinner

```{r}
plot_four_sets_sin_alc <- plot_sin_alc_small_prior |>
  filter(set_number == 1 | set_number == 2 | set_number == 3 | set_number == 4)

four_set_boundaries_alc_sin_small_prior <- plot_sin_alc_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1 | set_number == 2 | set_number == 3 | set_number == 4)
```

```{r}
plot_sin_alc_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_rect(data = four_set_boundaries_alc_sin_small_prior, aes(x = NULL, y = NULL, xmin = xmin, xmax = xmax, 
                                       ymin = -Inf, ymax = Inf, fill = set_number), alpha = 0.2) + 
  geom_line(data = plot_four_sets_sin_alc, aes(y = win_prob_px)) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Alcaraz vs Sinner US Open Quarterfinal 2022",
       subtitle = "Probability of Alcaraz Winning Match",
       caption = "Prior contains 'lead-up' tournaments to the 2022 USO and 2022 USO itself",
       color = "Server") +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_sin_alc_small_prior))) +
  scale_fill_manual(values = fills[1:4]) +
  theme_bw(base_size = 14) +
  annotate("text", x = 285, y = 0.9, label = "Alcaraz wins") +
  annotate("text", x = 285, y = 0.85, label = "7-5")
```

::: {.notes}
Eventually, in the fourth set, Sinner has a match point, which is why Alcaraz's probability drops so low. Alcaraz saves it and ends up winning the set.
:::

## Case Study 1: Alcaraz vs Sinner

```{r}
plot_five_sets_sin_alc <- plot_sin_alc_small_prior |>
  filter(set_number == 1 | set_number == 2 | set_number == 3 | set_number == 4 | set_number == 5)

five_set_boundaries_alc_sin_small_prior <- plot_sin_alc_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1 | set_number == 2 | set_number == 3 | set_number == 4 | set_number == 5)
```

```{r}
plot_sin_alc_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_rect(data = five_set_boundaries_alc_sin_small_prior, aes(x = NULL, y = NULL, xmin = xmin, xmax = xmax, 
                                       ymin = -Inf, ymax = Inf, fill = set_number), alpha = 0.2) + 
  geom_line(data = plot_five_sets_sin_alc, aes(y = win_prob_px)) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Alcaraz vs Sinner US Open Quarterfinal 2022",
       subtitle = "Probability of Alcaraz Winning Match",
       caption = "Prior contains 'lead-up' tournaments to the 2022 USO and 2022 USO itself",
       color = "Server") +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_sin_alc_small_prior))) +
  scale_fill_manual(values = fills[1:5]) +
  theme_bw(base_size = 14) +
  annotate("text", x = 355, y = 0.25, label = "Alcaraz wins") +
  annotate("text", x = 355, y = 0.2, label = "6-3")
```

::: {.notes}
And eventually Alcaraz wins the match. We see that in the 5th set, as the match is nearing its end, you can see large jumps in win probability as the players break each others serves. These breaks of serve are generally more important in men's matches than they are in women's matches.
:::

## Posterior Distribution

```{r}
#| warning: false
#| output: false
p1_serving_df <- sin_serving |> slice(1:150)

p1_serving_df |>
  summarise(points_won = sum(PointWinner == 1),
            points_played = n(),
            prop_won = points_won / points_played)

alc_serving |>
  summarise(points_won = sum(PointWinner == 2),
            points_played = n(),
            prop_won = points_won / points_played)

p1_niter <- p1_serving_df |> nrow()

p1_prob_store <- double()
  
p1_serving <- p1_serving_df |>
    # also create indicator if serving player won the point
    mutate(server_won = ifelse(PointWinner == 1, 1, 0))
sin_serving <- sin_serving |>
    # also create indicator if serving player won the point
    mutate(server_won = ifelse(PointWinner == 1, 1, 0))

mod <- stan_glm(server_won ~ 1, data = p1_serving |> slice(1:p1_niter),
                    family = binomial,
                    prior_intercept = normal(prior_sin_logodds, prior_sin_sd_logodds),
                    seed = 123)
coef(mod) |> expit()

mod_full <-  stan_glm(server_won ~ 1, data = sin_serving,
                    family = binomial,
                    prior_intercept = normal(prior_sin_logodds, prior_sin_sd_logodds),
                    seed = 123)
coef(mod_full) |> expit()
# use above to pull specific probabilities at a state of the match

tibble_mod <- as_tibble(mod) |>
  mutate(prob = expit(`(Intercept)`)) |>
  rename(logodds = `(Intercept)`)

tibble_mod_full <- as_tibble(mod_full) |>
  mutate(prob = expit(`(Intercept)`)) |>
  rename(logodds = `(Intercept)`)


ggplot(data = tibble_mod, aes(x = prob)) +
  geom_density(adjust = 5, linewidth = 0.9)
ggplot(data = tibble_mod_full, aes(x = prob)) +
  geom_density(adjust = 5, linewidth = 0.9)

plot_df <- bind_rows(tibble_mod, tibble_mod_full,
                     prior_sin_df, .id = "type") |>
  mutate(type = fct_recode(type, "posterior1" = "1",
                           "posterior2" = "2",
                           "prior" = "3"),
         type = fct_relevel(type, c("prior", "posterior1", "posterior2")))
```

```{r}
#| output: false
ggplot(data = plot_df, aes(x = prob)) +
  geom_density(aes(linetype = "prior"), adjust = 2,
               linewidth = 0.9) + ## adjust smooths it out
  theme_minimal() +
  labs(title = "Prior Distribution for Jannik Sinner",
       x = "Sinner's Probability of Winning a Point (on serve)",
       y = "Density") +
  coord_cartesian(ylim = c(0, 17)) +
  theme_bw(base_size = 22)
```

```{r}
ggplot(data = plot_df, aes(x = prob)) +
  geom_density(aes(colour = type), adjust = 2,
               linewidth = 0.9) + ## adjust smooths it out
  theme_minimal() +
  labs(title = "Prior and Posterior Distributions at Specific Match State",
       x = "Sinner's Probability of Winning a Point (on serve)",
       y = "Density",
       caption = "Posterior1: Midway through Match \n Posterior2: End of Match") +
  coord_cartesian(ylim = c(0, 17)) +
  scale_colour_viridis_d(end = 0.9) +
  theme_bw(base_size = 22)
```

::: {.notes}
And all the while, as the points are being played, the point win probability distributions are being updated.
:::

<!-- ## Posterior Sampling -->

<!-- * posterior distribution sampled 4000 times  -->
<!--     * each of the 4000 draws is plugged in to the match-win probability chain. -->
<!-- * even if center of posterior distribution does not change, match-win probability will still be affected by the posterior distribution variability. -->
    
## Case Study 1: Changing Prior

```{r}
#| output: false
#| cache: true
combined_prob_alc_sin_lp_df <- get_probabilities_df(p1_serving_df = sin_serving,
                                 p2_serving_df = alc_serving,
                                 p1 = "Jannik Sinner",
                                 p2 = "Carlos Alcaraz",
                                 p1_original_prob = 0.4288085,
                                 p1_original_se = 0.04919170,
                                 p2_original_prob = 0.4795682,
                                 p2_original_se = 0.04971023)

plot_sin_alc_large_prior <- get_plot_df(combined_df = combined_prob_alc_sin_lp_df,
                                        which_player_prob = 2,
                                        best_of_3 = FALSE,
                                        advantage = FALSE,
                                        type = "distribution") |>
  mutate(set_number = as.factor(as.numeric(total_sets))) |>
  # fix last row in data set where set_number is 6, should be a 5
  mutate(set_number = ifelse(pt_number == max(pt_number), '5', set_number)) |>
  mutate(set_number = as.factor(set_number))

sin_serving_fp <- sin_serving |> 
  mutate(player1 = "Jannik Sinner",
         player2 = "Carlos Alcaraz") |>
    # also create indicator if serving player won the point
    mutate(server_won = ifelse(PointWinner == 1, 1, 0))

alc_serving_fp <- alc_serving |> 
  mutate(player1 = "Jannik Sinner",
         player2 = "Carlos Alcaraz") |>
    # also create indicator if serving player won the point
    mutate(server_won = ifelse(PointWinner == 2, 1, 0))

combined_sin_alc_fixed_df <- bind_rows(sin_serving_fp, alc_serving_fp) |>
    arrange(pt_number) |>
  mutate(p1_wserv_prob = 0.68,
         p2_wserv_prob = 0.68) |>
  mutate(P1SetsWon = cumsum(SetWinner == 1),
           P2SetsWon = cumsum(SetWinner == 2)) |>
  select(pt_number, player1, player2, PointServer, p1_wserv_prob, p2_wserv_prob,
         P1PointsWon, P2PointsWon, P1GamesWon, P2GamesWon, P1SetsWon, P2SetsWon) |>
  mutate(PointServer = case_when(P1PointsWon == 0 & P2PointsWon == 0 & PointServer == 1 ~ 2,
                                 P1PointsWon == 0 & P2PointsWon == 0 & PointServer == 2 ~ 1,
                                 TRUE ~ PointServer))

plot_sin_alc_fixed_prior <- get_plot_df(combined_df = combined_sin_alc_fixed_df, 
                        which_player_prob = 2,
                        best_of_3 = FALSE,
                        advantage = FALSE,
                        type = "mean") |>
  mutate(set_number = as.factor(as.numeric(total_sets))) |>
  # fix last row in data set where set_number is 6, should be a 5
  mutate(set_number = ifelse(pt_number == max(pt_number), '5', set_number)) |>
  mutate(set_number = as.factor(set_number))
```

```{r}
plot_sin_alc_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_line(aes(y = win_prob_px, 
                color = factor("Small Prior", levels = c("Small Prior", "Large Prior", "Fixed Probability"))), 
                alpha = 0.9) +
  geom_line(data = plot_sin_alc_large_prior, aes(y = win_prob_px, color = "Large Prior"), alpha = 0.5) +
  geom_line(data = plot_sin_alc_fixed_prior, aes(y = win_prob_px, color = "Fixed Probability (0.68)"), alpha = 0.5) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Alcaraz vs Sinner US Open Quarterfinal 2022",
       subtitle = "Probability of Alcaraz Winning Match with Different Priors",
       caption = "Comparing Different Prior Distributions",
       color = "Server") +
  scale_color_manual(values = c("Small Prior" = "red", "Large Prior" = "blue", "Fixed Probability" = "green"),
                     labels = c("Small Prior", "Large Prior", "Fixed Probability (0.68)")) +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_sin_alc_small_prior))) +
  scale_colour_viridis_d(end = 0.9) +
  theme_bw(base_size = 14) +
  annotate("text", x = 110, y = 0.2, label = "Starting Win-Serve Probabilities:", size = 3.5, color = "black") +
  annotate("text", x = 110, y = 0.15, 
           label = paste0("'Small Prior - '*p[alcaraz]: 0.6229*', '*p[sinner]: 0.5606"), size = 3.5, color = "black",
           parse = TRUE) +
  annotate("text", x = 110, y = 0.1, 
           label = paste0("'Large Prior - '*p[alcaraz]: 0.61768*', '*p[sinner]: 0.6056"), size = 3.5, color = "black",
           parse = TRUE) +
  annotate("text", x = 110, y = 0.05, 
           label = "'Fixed Probability - '*p[alcaraz]: 0.68*', '*p[sinner]: 0.68", size = 3.5, color = "black",
           parse = TRUE)
```

::: {.notes}
A cool part of the project is that you can change the prior distribution to include more or fewer matches. This affects both the prior distribution center as well as the spread. In general, the more matches that are included in the prior distribution, the less affect that the data, or the points from the current match, has on the posterior distribution.
:::

## Case Study 2: Gauff vs Sabalenka

-   In the 2023 US Open, Coco Gauff faced Aryna Sabalenka in the finals
-   Gauff defeated Sabalenka in 3 sets, 2-6, 6-3, 6-2
-   We will look at probability of Gauff winning the match
-   Probability of winning a point on serve at the start of the match:
    -   $\tilde{p}_{gauff} : 0.5880$
    -   $\tilde{p}_{sabalenka} : 0.5475$

::: {.notes}
We can do this same thing for a women's match, in this case the 2023 U.S. Open final between Gauff and Sabalenka.
:::

## Case Study 2: Gauff vs Sabalenka

```{r}
#| output: false
#| cache: true
gauff_sab_paired <- wrangle_point_level(ext = "2023-usopen-points.csv",
                               ID = "2023-usopen-2701")

gauff_serving <- gauff_sab_paired[[1]]
saba_serving <- gauff_sab_paired[[2]]

combined_prob_gauff_sab_sp_df <- get_probabilities_df(p1_serving_df = gauff_serving,
                                 p2_serving_df = saba_serving,
                                 p1 = "Coco Gauff",
                                 p2 = "Aryna Sabalenka",
                                 p1_original_prob = 0.3555439,
                                 p1_original_se = 0.1026245,
                                 p2_original_prob = 0.1906711,
                                 p2_original_se = 0.1049427)

plot_gauff_sab_small_prior <- get_plot_df(combined_df = combined_prob_gauff_sab_sp_df,
                                        which_player_prob = 1,
                                        best_of_3 = TRUE,
                                        advantage = FALSE,
                                        type = "distribution") |>
  mutate(set_number = as.factor(as.numeric(total_sets))) |>
  # fix last row in data set where set_number is 6, should be a 5
  mutate(set_number = ifelse(pt_number == max(pt_number), '3', set_number)) |>
  mutate(set_number = as.factor(set_number))

plot_first_set_gauff_sab <- plot_gauff_sab_small_prior |>
  filter(set_number == 1)

first_set_boundaries_gauff_sab_small_prior <- plot_gauff_sab_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1)
```


```{r}
plot_three_set_gauff_sab <- plot_gauff_sab_small_prior |>
  filter(set_number == 1 | set_number == 2 | set_number == 3)

three_set_boundaries_gauff_sab_small_prior <- plot_gauff_sab_small_prior |>
  group_by(set_number) |>
  summarize(xmin = min(pt_number) - 0.5,
            xmax = max(pt_number) + 0.5) |>
  filter(set_number == 1 | set_number == 2 | set_number == 3)
```

```{r}
plot_gauff_sab_small_prior |> ggplot(aes(x = pt_number, y = probability)) +
  geom_rect(data = three_set_boundaries_gauff_sab_small_prior, aes(x = NULL, y = NULL, xmin = xmin, xmax = xmax, 
                                       ymin = -Inf, ymax = Inf, fill = set_number), alpha = 0.2) + 
  geom_line(data = plot_three_set_gauff_sab, aes(y = win_prob_px)) +
  labs(x = "Point Number",
       y = "Probability of Winning Match",
       title = "Gauff vs Sabalenka US Open Final 2023",
       subtitle = "Probability of Gauff Winning Match",
       caption = "Prior contains 'lead-up' tournaments to the 2023 USO and 2023 USO itself",
       color = "Server") +
  coord_cartesian(ylim = c(0, 1),
                  xlim = c(0, nrow(plot_gauff_sab_small_prior))) +
  scale_fill_manual(values = fills[1:3]) +
  theme_bw(base_size = 14) 
```

::: {.notes}
Jumping straight to the end, the interesting thing to note is that, for women's matches, breaks of serve are more common, so, the match win probability graphs are generally not as "jumpy" since breaks of serve are easier to come by.
:::

## Undergraduate vs. Graduate Work

* balance with technical understanding and application
* a student should be able to:
    * explain the purpose of a Bayesian analysis.
    * explain the difference between a Bayesian and frequentist analysis in that "parameters" are treated as random in a Bayesian analysis.
    * re-construct every aspect of the data wrangling and analysis processes.

::: {.notes}
So, that was a brief overview of this undergraduate research project. I chose this one to present because it's probably been my favorite project so far, and the student who worked on it did a superb job. 

Something that I think about often in all of these undergraduate research projects is how to get the right balance of technical understanding with application. In this case, I think a student should be able to explain the purpose of a bayesian analysis, explain the difference between the Bayesian and frequentist analysis, and essentially perform all of the data wrangling and analysis processes.
:::

## Undergraduate vs. Graduate Work

* there is not enough time to deeply discuss things like:
    * how the posterior distribution is sampled (MCMC sampling is performed with `rstanarm` package)
        <!-- * especially compared to me writing my own MCMC sampler. -->
    * some of the more technical aspects of Bayesian analysis like chain convergence, the burn-in period, etc.

::: {.notes}
But, unlike graduate work, there is not enough time to talk about _all_ of the technical details. For example, we used the `stan_glm()` function from the `rstanarm` package to obtain the posterior distributions. We only talked for a very short time about how this posterior distribution is actually obtained: diving into MCMC is just too much for this project. 

We also glossed over some of the more technical aspects like diagnostic checks. 
:::

## The Balance is Hard!!

* want enough technical background to know what is going on and when the method is appropriate.
* do not want to focus so much on the technical background that there is no time for the data-specific application.

::: {.notes}
I find this balance to be the toughest part of these projects. Glossing over things always makes me feel a little guilty, but, again, these projects are not theses and some things have to get cut. And some glossing over just has to be done for the student to have an interesting final project!
:::

## Undergraduate vs. Graduate Work: The Outcome

* more focus into GitHub repository than a publishable paper.
* more focus on the student honing a wide variety of skills.

::: {.notes}
And a final general difference I find between undergraduate and graduate work is the actual final product. For undergraduates, it often makes more sense to focus more on the GitHub repository with the project. That is the most public-facing part since publishing in academic journals is somewhat rare.

I think there is also more of focus on practicing a variety of skills in an undergraduate project whereas, particular for PhD work, you're often very focused on something that is super specific.
:::



## `spmodel`

![](mipha_pics/spmodel_logo.png)

## Acknowledgments

* Ben Moolman (undergraduate student, future Iowa State student)
* Dr. Lisa Madsen
* Tennis data:

    * GitHub repository run by Jeff Sackmann
    * `deuce` `R` package created by Stephanie Kovalchik
    
## Questions

* JSM 2024
* email: `mhigham@stlawu.edu`







